**Подготовка к теоретической части собеседования [Python]**

1) *Что такое контекстный менеджер?*

   -> Контекстный менеджер - которые определяет вход и выход из контекста при помощи методов __enter__(), __exit__()
   Чаще всего используется для управления ресурсами например открытие и закрытие файлов/подключений к бд.

---

2) *В чём разница между пакетами и модулями?*

   -> Модуль - это один файл с python кодом который можно импортировать в другие части программы для своих нужд.
   Пакет - это директория которая может содержать множество модулей и поддиректорий с python кодом. При этом обязательно
   наличие файла __init__.py в котором можно инициализировать переменные, ф-ии и классы для данного пакета. Делается это
   для того чтобы сделать их доступными для других модулей внутри данного пакета.

---

3) *Опишите процесс компиляции в python.*

   -> Python - сам по себе интерпретируемый язык и не требует отдельного этапа компиляции как Java. Однако существует
   процесс компиляции байт кода. Он устроен следующим образом. Внутри интерпретатора языка содержится урезанная версия
   компилятора... Когда мы запускаем код в первую очередь компилятор пробегается по всему коду смотрит есть ли
   синтаксические ошибки если их нет то переводит программу в байт код который в свою очередь сохраняется в папке _
   _pycache__. Дальше этот код запускается на PVM - python virtual machine и производит требуемые от программы действия.

   Интерпретируемый он из за того что логические ошибки такие как несоответствие типов деление на 0 и т.д будут выявлены
   только при исполнении байт кода.

   ATTENTION! В случае если модуль не был изменён с момента последнего запуска процесс компиляции повторно запускаться
   НЕ будет. Ведь данные сохранены в __pycache__.

---

4) *Как получить доступ к C в Python?*

   -> Существует библиотека ctypes.
   ```python
   from ctypes import cdll
   libm = cdll.LoadLibrary('libm.so')
   print(libm.sqrt(4.0))
   ```

---

5) *Для чего в пакетах модулей python в файле __init__.py служит список __all__?*

   -> В файлах __init__.ру списки __all__ используются для определения, что экспортировать, когда каталог импортируется
   с помощью формы оператора from module import *.

---

6) *Какую роль в описании метода класса выполняет декоратор @property?*

   -> Декоратор @property позволяет обращаться к методу экземпляра как к атрибуту. То есть, к примеру, a.size, а не
   a.size(). При этом само значение метода size вычисляется, как метод класса.

---

7) *Что такое метаклассы и в каких случаях их следует использовать?*

   -> Обычные класс - это чертёж/инструкция для создания объектов наделённых определёнными свойствами и методами.
   Метакласс - это чертёж для чертежей. Он описывает то какими свойствами должны обладать классы которые от него
   создаются. Своего рода класс для классов. Необходимо использовать если нужно добавить определённой группе классов
   какие то свойства.

--- 

8) *Декораторы в классах. Какие бывают?*

   -> @classmethod - метод становится методом класса. Должен быть аргумент cls. К таким можно обращаться прямо через
   класс.
   @staticmethod - ф-ия которая по логике должна находиться внутри класса. Можно обращаться как через объект так и через
   класс.
   @property - позволяет создавать вычисляемые атрибуты на основе методов. Эта особенность позволяет создавать геттеры и
   сеттеры.

---

9) *Что такое SOLID?*

   -> Подход созданный для стандартизации написания кода в ООП стиле.
    - S - [single-responsibility principle] - принцип единственной ответственности. Один класс решает одну задачу.
      Задачу нужно всегда декомпозировать на несколько более мелких задач. Каждую из которых необходимо отдельно
      реализовывать в своём классе.
    - O - [open-closed principle] - программные сущности должны быть открыты для расширения но закрыты для модификации.
    - L - [liskov substitution principle] - производные классы должны заменять свои базовые классы. Дочерние классы
      должны сохранять атрибуты и методы родительских. Для этого удобно использовать абстрактные классы от которых
      наследуются дочерние. По итогу в каждом дочернем классе необходимый метод будет реализовываться как нужно именно
      здесь. При этом поведение в абстрактном классе не будет нарушено т.к у него абстрактный метод который и так ничего
      не делает.
    - I - [interface segregation principle] - клиенты не должны зависеть от интерфейсов которые они не используют. Не
      нужно создавать один огромный интерфейс. Лучше разбить его на множество мелких и подключать к классу только те
      которые действительно нужны.
    - D - [dependency inversion principle] - модули высокого уровня не должны зависеть от низкого уровня. Они должны
      зависеть от абстракций. Абстракции не должны зависеть от деталей а детали от абстракций.

---

10) *Что такое миксины?*

    -> Миксины - это маленькие классы которые содержат ограниченное кол-во методов и не содержат состояния объектов.
    Используются для того чтоб подмешивать дополнительный функционал при помощи механизма множественного наследования.
    Нельзя создать объект от такого класса.

---

11) *Что такое KISS?*

    -> KISS [Keep. It. Simple. Stupid.] - шаблон проектирования который рекомендует не переусложнять код и не пытаться
    затащить в проект вообще всё что знаешь. Старайся написать код так чтоб его мог понять даже стажёр. Чем проще тем
    лучше.
    Не следует применять миллион патернов проектирования и делать бесконечный уровень абстракции.
   